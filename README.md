---

RADAR — поиск и оценка «горячих» финансовых новостей

Асинхронный сервис, который собирает новости из разных источников, дедуплицирует их, ранжирует по «горячести» (hotness), строит таймлайн подтверждений и отдает готовый **черновик публикации/заметки** с проверяемыми ссылками.

---

## Содержание

* [Идея и ценность](#идея-и-ценность)
* [Ключевые возможности](#ключевые-возможности)
* [Архитектура и пайплайн](#архитектура-и-пайплайн)
* [Метрика «горячести» (hotness)](#метрика-горячести-hotness)
* [Схема ответа API](#схема-ответа-api)
* [Быстрый старт](#быстрый-старт)
* [Конфигурация](#конфигурация)
* [HTTP API](#http-api)
* [Качество данных и анти-дезинформация](#качество-данных-и-анти-дезинформация)
* [Разработка и структура проекта](#разработка-и-структура-проекта)
* [Роадмап](#роадмап)
* [Лицензия](#лицензия)

---

## Идея и ценность

Финансовые рынки перегружены информацией: релизы компаний, заявления регуляторов, отраслевые СМИ, X/Telegram, судебные документы и пр. Важно **рано** отфильтровать шум и понять, **почему эта новость важна сейчас**: неожиданность относительно консенсуса, подтверждения из независимых источников, масштаб затронутых активов, скорость распространения.

**RADAR** формализует эти принципы и возвращает компактный, верифицируемый результат, который удобно использовать как основу для аналитической заметки, поста или торгового сигнала.

---

## Ключевые возможности

* **Сбор**: RSS + RSS-Bridge и иные HTTP-источники (расширяемая система коннекторов).
* **Асинхронный парсинг**: `aiohttp`/`asyncio`, неблокирующие запросы, конвейерная обработка.
* **Дедупликация и кластеризация**: склейка перепечаток/зеркал, подсчет дублей и «скорости распространения».
* **Ранжирование по «горячести»**: композиция метрик (новизна, скорость, подтверждения, репутация источника, охват сущностей).
* **Таймлайн**: первая публикация → подтверждение → уточнение.
* **Черновик публикации**: заголовок, лид, 3 буллета и цитата/сноска — с проверяемыми ссылками.
* **HTTP API** (FastAPI): `GET /radar?window=24&k=5`, интерактивные `/docs`.
* **LLM-помощник (опционально)**: генерация аккуратного черновика через совместимый endpoint (например, OpenRouter), строгий системный промпт.
* **Готовность к продакшену**: изоляция конфигурации через `.env`, докеризация вспомогательных сервисов (RSS-Bridge), логирование.

**Технологии**: Python 3.11+, `FastAPI`, `uvicorn`, `aiohttp`, `pydantic`, Docker (RSS-Bridge), (опц.) LLM через HTTP (например, OpenRouter).

---

## Архитектура и пайплайн

```
Sources (RSS / RSS-Bridge / HTTP)
              │
              ▼
        Ingestion (async fetchers)
              │
              ▼
      Parsing & Normalization
              │
              ├── Dedup/Clustering (по URL/заголовкам/семантике)
              │
              ├── Entity Extraction (тикеры/компании/страны/сектора)
              │
              └── Source Reputation / Confirmations
              │
              ▼
        Hotness Scoring (веса + time-decay)
              │
              ▼
      Timeline Builder & Draft Generator
              │
              └── (опц.) LLM endpoint для «draft»
              │
              ▼
          FastAPI /radar (JSON)
```

Модули логически разделены: коннекторы источников, нормализация, дедуп, скоринг, таймлайн, генерация черновика, слой API.

---

## Метрика «горячести» (hotness)

Скоринг — взвешенная композиция нормализованных метрик:

* **recency** — новизна события с экспоненциальным затуханием времени (half-life, ч.).
* **velocity** — скорость «размножения» сюжета (tanh-нормализация по приросту дублей/зеркал).
* **confirmations** — количество независимых подтверждений/ссылок в тексте.
* **source_rep** — репутация источника (агентства/регуляторы > репост-ленты).
* **entities** — широта/важность затронутых сущностей (тикеры, страны, секторы).

Типичные параметры (перенастраиваются в конфиге/ENV):

* `TIME_DECAY_HALF_LIFE_HOURS = 6.0`
* `VELOCITY_SCALE = 3.0`
* `MAX_CONFIRMATIONS_NORM = 3.0`
* `WEIGHTS = {recency: 0.25, velocity: 0.30, confirmations: 0.18, source_rep: 0.17, entities: 0.10}`

---

## Схема ответа API

```json
{
  "headline": "Краткий заголовок события",
  "hotness": 0.0,
  "why_now": "1–2 фразы: почему важно сейчас (новизна, подтверждения, масштаб)",
  "entities": ["AAPL", "Semiconductors", "US"],
  "sources": [
    "https://первый-источник",
    "https://подтверждение",
    "https://уточнение"
  ],
  "timeline": [
    {"t": "2025-10-04T10:05:00Z", "note": "первое сообщение"},
    {"t": "2025-10-04T10:17:00Z", "note": "подтверждение"},
    {"t": "2025-10-04T12:42:00Z", "note": "уточнение параметров"}
  ],
  "draft": {
    "title": "Заголовок для поста",
    "lead": "Лид-абзац с фактажом и контекстом.",
    "bullets": [
      "Ключевой факт №1",
      "Ключевой факт №2",
      "Связанные активы/риски"
    ],
    "quote": "Цитата/сноска с атрибуцией"
  },
  "dedup_group": "cluster-id"
}
```

---

## Быстрый старт

### 1) Зависимости

* Python **3.11+**
* Docker (для **RSS-Bridge**)
* (опц.) ключ для LLM-endpoint (например, `OPENROUTER_API_KEY`)

```bash
# В корне проекта
python -m venv .venv
source .venv/bin/activate
cp .env.example .env    # создайте и заполните .env
```

### 2) Запуск RSS-Bridge (Docker)

Создайте `services/rss_bridge/docker-compose.yml`:

```yaml
services:
  rss-bridge:
    image: rssbridge/rss-bridge:latest
    ports:
      - "3000:80"
    environment:
      - TZ=UTC
    restart: unless-stopped
```

```bash
cd services/rss_bridge
docker compose up -d
```

### 3) Запуск API

```bash
# пример запуска встроенного API
python -m services.api.src.api
# или
uvicorn services.api.src.api:app --reload --host 0.0.0.0 --port 8000
```

Откройте Swagger: [http://127.0.0.1:8000/docs](http://127.0.0.1:8000/docs)

Пример запроса:

```
GET /radar?window=24&k=5
```

---

## Конфигурация

Создайте `.env` и укажите нужные значения:

```
# LLM (опционально)
OPENROUTER_API_KEY=...

# Метрики hotness
TIME_DECAY_HALF_LIFE_HOURS=6.0
VELOCITY_SCALE=3.0
MAX_CONFIRMATIONS_NORM=3.0
WEIGHTS='{"recency":0.25,"velocity":0.30,"confirmations":0.18,"source_rep":0.17,"entities":0.10}'

# Источники / коннекторы
RSS_BRIDGE_URL=http://localhost:3001
SOURCES_CONFIG=./config/sources.csv
```

> Формат `SOURCES_CONFIG`: имя, тип (`rss`/`http`/`bridge`), URL, флаги проверки SSL, лимиты, теги и т.д.

---

## HTTP API

* `GET /radar?window=<часы>&k=<топ-N>` — вернуть топ-K событий в заданном окне.

  * `window` (int, часы) — период анализа, по умолчанию `24`.
  * `k` (int) — размер витрины (топ-лист), по умолчанию `5`.
* `GET /health` — проверка готовности.
* `GET /docs` — интерактивная спецификация OpenAPI/Swagger.

Коды ответов: `200 OK`, `400 Bad Request`, `500 Internal Server Error` (с трассировкой в логах).

---

## Качество данных и анти-дезинформация

* **Дедупликация**: сглаживаем перепечатки/зеркала, учитываем канонический URL и близость заголовков/времени.
* **Подтверждения**: считаем независимые ссылки/упоминания в тексте.
* **Репутация источников**: агентства/регуляторы имеют больший вес, чем агрегаторы.
* **Таймлайн**: фиксируем цепочку «первое сообщение → подтверждение → уточнение».
* **Защита от устаревших материалов**: time-decay, явные окна анализа, контроль «старых» публикаций.
* **Проверяемость**: каждая ключевая фраза «почему важно сейчас» привязана к первоисточнику.

---

## Разработка и структура проекта

Типичная структура (может отличаться в вашей версии; ориентир для навигации):

```
.
├── services/
│   ├── api/
│   │   └── src/
│   │       └── api.py            # FastAPI приложение (/radar, /health, /docs)
│   ├── radar_parser/
│   │   ├── src/
│   │   │   ├── __main__.py       # CLI/entrypoint (опц.)
│   │   │   ├── service.py        # асинхронный сбор, скоринг, генерация ответа
│   │   │   └── llm_async_adapter.py # build_llm_payload, вызов LLM (опц.)
│   └── rss_bridge/
│       └── docker-compose.yml    # локальный RSS-Bridge
├── config/
│   └── sources.csv               # конфигурация источников (пример)
├── .env.example
├── requirements.txt
└── README.md
```

### Стек и практики

* **Python**: `asyncio`, `aiohttp`, `pydantic` для валидации.
* **API**: `FastAPI` + `uvicorn`, типизированные модели, OpenAPI.
* **LLM** (опц.): HTTP-клиент к совместимому endpoint (например, OpenRouter) с четким system-prompt.
* **Докеризация**: RSS-Bridge через `docker compose`.
* **Логи/отладка**: структурированные логи, понятные ошибки в API.
* **Конфиги**: `.env` + явные параметры метрик и весов.

---

## Роадмап

* Поддержка дополнительных источников (регистратуры/SEC/EDGAR, корпоративные RSS).
* Мультиязычность и часовые пояса, нормализация локалей.
* Онлайновый режим (streaming) и веб-хуки/алерты.
* Кэш и эмбеддинги для ускорения повторных запросов.
* Бэктест на историческом окне (корреляция hotness ↔ последующая волатильность).
* Telegram-бот/веб-панель для публикации черновиков.

---

### Быстрая проверка

1. Поднимите `rss-bridge` в Docker.
2. Запустите API (`uvicorn ...`).
3. Зайдите на `/docs` и вызовите `GET /radar?window=24&k=5`.

Если что-то упало — смотрите логи `uvicorn` и корректность `.env` (особенно URL источников и ключи для опциональных LLM).

---
